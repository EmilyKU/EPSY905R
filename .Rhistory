prob1 = cprob1 - cprob2
prob2 = cprob2 - cprob3
prob3 = cprob3 - 0
plot(c(prob0, prob1, prob2, prob3))
barplot(height = c(prob0, prob1, prob2, prob3), ylim = c(0,1))
Bi1 = -2
Bi2 = 0
Bi3 = 2
theta = -2.5
a = -20
#cumulative probabities
cprob1 = exp(a*(theta-Bi1))/(1+exp(a*(theta - Bi1))) # Prob y = 1, 2, 3
cprob2 = exp(a*(theta-Bi2))/(1+exp(a*(theta - Bi2))) # Prob y = 2, 3
cprob3 = exp(a*(theta-Bi3))/(1+exp(a*(theta - Bi3))) # Prob y = 3
# prob0 = cprob y = 0, 1, 2 ,3 - cprob y = 1, 2, 3
prob0 = 1 - cprob1
prob1 = cprob1 - cprob2
prob2 = cprob2 - cprob3
prob3 = cprob3 - 0
plot(c(prob0, prob1, prob2, prob3))
barplot(height = c(prob0, prob1, prob2, prob3), ylim = c(0,1))
Bi1 = -2
Bi2 =  0
Bi3 =  2
theta = -2.5
a = 1
#cumulative probabities
cprob1 = exp(a*(theta-Bi1))/(1+exp(a*(theta - Bi1))) # Prob y = 1, 2, 3
cprob2 = exp(a*(theta-Bi2))/(1+exp(a*(theta - Bi2))) # Prob y = 2, 3
cprob3 = exp(a*(theta-Bi3))/(1+exp(a*(theta - Bi3))) # Prob y = 3
# prob0 = cprob y = 0, 1, 2 ,3 - cprob y = 1, 2, 3
prob0 = 1 - cprob1
prob1 = cprob1 - cprob2
prob2 = cprob2 - cprob3
prob3 = cprob3 - 0
plot(c(prob0, prob1, prob2, prob3))
barplot(height = c(prob0, prob1, prob2, prob3), ylim = c(0,1))
Bi1 = -2
Bi2 =  0
Bi3 =  2
theta = -2
a = 1
#cumulative probabities
cprob1 = exp(a*(theta-Bi1))/(1+exp(a*(theta - Bi1))) # Prob y = 1, 2, 3
cprob2 = exp(a*(theta-Bi2))/(1+exp(a*(theta - Bi2))) # Prob y = 2, 3
cprob3 = exp(a*(theta-Bi3))/(1+exp(a*(theta - Bi3))) # Prob y = 3
# prob0 = cprob y = 0, 1, 2 ,3 - cprob y = 1, 2, 3
prob0 = 1 - cprob1
prob1 = cprob1 - cprob2
prob2 = cprob2 - cprob3
prob3 = cprob3 - 0
plot(c(prob0, prob1, prob2, prob3))
barplot(height = c(prob0, prob1, prob2, prob3), ylim = c(0,1))
Bi1 = -2
Bi2 =  -1.99
Bi3 =  2
theta = -2
a = 1
#cumulative probabities
cprob1 = exp(a*(theta-Bi1))/(1+exp(a*(theta - Bi1))) # Prob y = 1, 2, 3
cprob2 = exp(a*(theta-Bi2))/(1+exp(a*(theta - Bi2))) # Prob y = 2, 3
cprob3 = exp(a*(theta-Bi3))/(1+exp(a*(theta - Bi3))) # Prob y = 3
# prob0 = cprob y = 0, 1, 2 ,3 - cprob y = 1, 2, 3
prob0 = 1 - cprob1
prob1 = cprob1 - cprob2
prob2 = cprob2 - cprob3
prob3 = cprob3 - 0
plot(c(prob0, prob1, prob2, prob3))
barplot(height = c(prob0, prob1, prob2, prob3), ylim = c(0,1))
Bi1 = -2
Bi2 =  1.99
Bi3 =  2
theta = -2
a = 1
#cumulative probabities
cprob1 = exp(a*(theta-Bi1))/(1+exp(a*(theta - Bi1))) # Prob y = 1, 2, 3
cprob2 = exp(a*(theta-Bi2))/(1+exp(a*(theta - Bi2))) # Prob y = 2, 3
cprob3 = exp(a*(theta-Bi3))/(1+exp(a*(theta - Bi3))) # Prob y = 3
# prob0 = cprob y = 0, 1, 2 ,3 - cprob y = 1, 2, 3
prob0 = 1 - cprob1
prob1 = cprob1 - cprob2
prob2 = cprob2 - cprob3
prob3 = cprob3 - 0
plot(c(prob0, prob1, prob2, prob3))
barplot(height = c(prob0, prob1, prob2, prob3), ylim = c(0,1))
Bi1 = -20
Bi2 =  0
Bi3 =  2
theta = -2
a = 1
#cumulative probabities
cprob1 = exp(a*(theta-Bi1))/(1+exp(a*(theta - Bi1))) # Prob y = 1, 2, 3
cprob2 = exp(a*(theta-Bi2))/(1+exp(a*(theta - Bi2))) # Prob y = 2, 3
cprob3 = exp(a*(theta-Bi3))/(1+exp(a*(theta - Bi3))) # Prob y = 3
# prob0 = cprob y = 0, 1, 2 ,3 - cprob y = 1, 2, 3
prob0 = 1 - cprob1
prob1 = cprob1 - cprob2
prob2 = cprob2 - cprob3
prob3 = cprob3 - 0
plot(c(prob0, prob1, prob2, prob3))
barplot(height = c(prob0, prob1, prob2, prob3), ylim = c(0,1))
Bi1 = -20
Bi2 =  -19
Bi3 =  2
theta = -2
a = 1
#cumulative probabities
cprob1 = exp(a*(theta-Bi1))/(1+exp(a*(theta - Bi1))) # Prob y = 1, 2, 3
cprob2 = exp(a*(theta-Bi2))/(1+exp(a*(theta - Bi2))) # Prob y = 2, 3
cprob3 = exp(a*(theta-Bi3))/(1+exp(a*(theta - Bi3))) # Prob y = 3
# prob0 = cprob y = 0, 1, 2 ,3 - cprob y = 1, 2, 3
prob0 = 1 - cprob1
prob1 = cprob1 - cprob2
prob2 = cprob2 - cprob3
prob3 = cprob3 - 0
plot(c(prob0, prob1, prob2, prob3))
barplot(height = c(prob0, prob1, prob2, prob3), ylim = c(0,1))
Bi1 = -2
Bi2 =  -1.99
Bi3 =  2
theta = -2
a = 1
#cumulative probabities
cprob1 = exp(a*(theta-Bi1))/(1+exp(a*(theta - Bi1))) # Prob y = 1, 2, 3
cprob2 = exp(a*(theta-Bi2))/(1+exp(a*(theta - Bi2))) # Prob y = 2, 3
cprob3 = exp(a*(theta-Bi3))/(1+exp(a*(theta - Bi3))) # Prob y = 3
# prob0 = cprob y = 0, 1, 2 ,3 - cprob y = 1, 2, 3
prob0 = 1 - cprob1
prob1 = cprob1 - cprob2
prob2 = cprob2 - cprob3
prob3 = cprob3 - 0
plot(c(prob0, prob1, prob2, prob3))
barplot(height = c(prob0, prob1, prob2, prob3), ylim = c(0,1))
Bi1 = -2
Bi2 =  -1.99
Bi3 =  2
theta = -2
a = .1
#cumulative probabities
cprob1 = exp(a*(theta-Bi1))/(1+exp(a*(theta - Bi1))) # Prob y = 1, 2, 3
cprob2 = exp(a*(theta-Bi2))/(1+exp(a*(theta - Bi2))) # Prob y = 2, 3
cprob3 = exp(a*(theta-Bi3))/(1+exp(a*(theta - Bi3))) # Prob y = 3
# prob0 = cprob y = 0, 1, 2 ,3 - cprob y = 1, 2, 3
prob0 = 1 - cprob1
prob1 = cprob1 - cprob2
prob2 = cprob2 - cprob3
prob3 = cprob3 - 0
plot(c(prob0, prob1, prob2, prob3))
barplot(height = c(prob0, prob1, prob2, prob3), ylim = c(0,1))
Bi1 = -2
Bi2 =  -1.99
Bi3 =  2
theta = -2
a = .5
#cumulative probabities
cprob1 = exp(a*(theta-Bi1))/(1+exp(a*(theta - Bi1))) # Prob y = 1, 2, 3
cprob2 = exp(a*(theta-Bi2))/(1+exp(a*(theta - Bi2))) # Prob y = 2, 3
cprob3 = exp(a*(theta-Bi3))/(1+exp(a*(theta - Bi3))) # Prob y = 3
# prob0 = cprob y = 0, 1, 2 ,3 - cprob y = 1, 2, 3
prob0 = 1 - cprob1
prob1 = cprob1 - cprob2
prob2 = cprob2 - cprob3
prob3 = cprob3 - 0
plot(c(prob0, prob1, prob2, prob3))
barplot(height = c(prob0, prob1, prob2, prob3), ylim = c(0,1))
Polytomous
Bi1 = -2
Bi2 =  -1.99
s = 1:500
x = 1:500
x = x/2.5
y = -((x/50)-1.5)^2 + sin(x/8) + sqrt(x)/5 + 2*log(x) + cos(x)
plot(x = x, y = y, type="l")
rnormPointer <- function(inputValue1, inputValue2){
object <- new.env(parent=globalenv())
object$distr <- inputValue1
object$n <- inputValue2
class(object) <- 'pointer'
object
}
ptrList <- vector("list", N)
N=10000
ptrList <- vector("list", N)
for(i in seq_along(nsize)) {
ptrList[[i]] <- rnormPointer(rnorm, nsize[i])
}
nsize = sample(1:100, size = N, replace = TRUE)
rnormPointer <- function(inputValue1, inputValue2){
object <- new.env(parent=globalenv())
object$distr <- inputValue1
object$n <- inputValue2
class(object) <- 'pointer'
object
}
ptrList <- vector("list", N)
for(i in seq_along(nsize)) {
ptrList[[i]] <- rnormPointer(rnorm, nsize[i])
}
format(object.size(ptrList), units = "Mb")
ptrList[[1]]
ptrList[[1]]
ptrList[[1]]$distr()
ptrList[[1]]$distr
ptrList[[1]]$distr(ptrList[[1]]$n)
lapply(X = ptrList, FUN = function(x) x$distr(x$n))
temp = lapply(X = ptrList, FUN = function(x) x$distr(x$n))
## Jonathan Templin
## Paul Johnson
## 20171122
## Testing alternative ways of storing symbols that might
## act as "function pointers"
N <- 10000
nsize = sample(x = 1:100, size = N, replace = TRUE)
# old method:
closureList = list()
for (i in 1:length(nsize)){
closureList[[i]] = list(func = rnorm, n = nsize[i])
}
object.size(closureList)
format(object.size(closureList), units = "Mb")
N <- 10000
alist <- vector("list", N)
nsize = sample(x = 1:100, size = N, replace = TRUE)
for (i in seq_along(nsize)){
alist[[i]] <- list(rnorm, nsize[i])
}
format(object.size(closureList), units = "Mb")
## pj: In C, one can pass a pointer to a function. The pointer
## requires almost no storage. In Objective-C, one can save a
## "lookup address" of an object, almost the same thing.
## In contrast, in R when we do something that has
## a function as an input, then the whole function is literally
## copied.  Using an argument *rnorm* is, literally, copy-pasting the
## parsed R code for *rnorm* into the middle of your function.
## here's an alternative that performs as well, but
## does not require as much storage
## R passes by value, except for environments. By sheltering
## a function in a new environment, we end up creating a smaller
## object list. Maybe (if we can trust size estimate)
## https://www.stat.berkeley.edu/~paciorek/computingTips/Pointers_passing_reference_.html
rnormPointer <- function(inputValue1, inputValue2){
object <- new.env(parent=globalenv())
object$distr <- inputValue1
object$n <- inputValue2
class(object) <- 'pointer'
object
}
## Experiment with that
gg <- rnormPointer(rnorm, 33)
gg$distr(gg$n)
gg$distr(gg$n)
## Make a collection of 10000 of them:
ptrList <- vector("list", N)
for(i in seq_along(nsize)) {
ptrList[[i]] <- rnormPointer(rnorm, nsize[i])
}
format(object.size(ptrList), units = "Mb")
## Note you can pass in the unnamed arguments for n, mean and sd here
ptrList[[1]]$distr(33)
ptrList[[1]]$distr(33, 100, 10)
## Or the named arguments
ptrList[[1]]$distr(1, sd = 100)
## The only reason I'd ever need "inputValue2" is to remember what
## I had for n, which is embedded in ptrList.
ptrList[[1]]$distr(ptrList[[1]]$n)
# method using quote function
quoteList = list()
for (i in 1:length(nsize)){
quoteList[[i]] = quote(rnorm(n=1))
quoteList[[i]]$n = nsize[i]
}
format(object.size(quoteList), units = "Mb")
quoteList2 <- vector("list", N)
for (i in seq_along(nsize)){
quoteList2[[i]] <- list(quote(rnorm), nsize[i])
}
format(object.size(quoteList2), units = "Mb")
quoteList3 <- vector("list", N)
for (i in seq_along(nsize)){
quoteList3[[i]] <- as.call(list(quote(rnorm), nsize[i]))
}
format(object.size(quoteList3), units = "Mb")
# method using quoted string
stringList = list()
for (i in 1:length(nsize)){
stringList[[i]] = paste0("rnorm(", nsize[i], ")")
}
format(object.size(stringList), units = "Mb")
## Previous will run slow because text string must be parsed when the
## distribution is used.  Parse that and save the parsed object.
## Note this makes storage size as big as closureList.
stringList2 <- vector("list", N)
for (i in seq_along(nsize)){
stringList2[[i]] <- parse(text = paste("rnorm(", nsize[i], ")"))
}
format(object.size(stringList2), units = "Mb")
#r benchmark timing
##if (!require("rbenchmark")) devtools::install_github("eddelbuettel/rbenchmark")
library(rbenchmark)
benchmark("closure" = {test = lapply(X = closureList, FUN = function(x) x$func(n = x$n))},
"quote" = {test = lapply(X = quoteList, FUN = function(x) eval(x))},
"string" = {test = lapply(X = stringList, FUN = function(x) eval(parse(text = x)))},
"string2" = {test = lapply(X = stringList2, FUN = function(x) eval(x))},
"pointer" = {test = lapply(ptrList, FUN = function(x) x$distr(x$n))},
"quote2" = {lapply(quoteList2, function(x) eval(as.call(x)))},
"quote3" = {lapply(quoteList3, function(x) eval(as.call(x)))},
replications = 100, columns = c("test", "replications", "elapsed", "relative", "user.self", "sys.self"))
install.packages("ggplot2")
install.packages("reshape2")
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
plot(pressure)
source("initialScripts.R")
#simulate data
set.seed(7)
natt = 2
nexam = 1000
nitem = 6
itemIntercept = -1.5
itemMainEffect = 3
itemInteraction = 0
maxIxn = 2
qmatrix = matrix(data = 0, nrow = nitem, ncol = natt)
qmatrix[1:3,1] = 1
qmatrix[4:6,2] = 1
simulated = generate_simple_dcm2d(qmatrix = qmatrix, nExam = nexam, itemIntercept = itemIntercept,
itemMainEffect = itemMainEffect, itemInteraction = itemInteraction)
getwd()
source("/Users/jonathantemplin/Documents/repos/blatent/estimation/initial/initialScripts.R")
#simulate data
set.seed(7)
natt = 2
nexam = 1000
nitem = 6
itemIntercept = -1.5
itemMainEffect = 3
itemInteraction = 0
maxIxn = 2
qmatrix = matrix(data = 0, nrow = nitem, ncol = natt)
qmatrix[1:3,1] = 1
qmatrix[4:6,2] = 1
simulated = generate_simple_dcm2d(qmatrix = qmatrix, nExam = nexam, itemIntercept = itemIntercept,
itemMainEffect = itemMainEffect, itemInteraction = itemInteraction)
dataMat = simulated$data
qmatrix = qmatrix
dpmOptions = dpmControl(seed=1, parallel=FALSE)
if (dpmOptions$parallel){
#initialize parallel package
library(parallel)
#set number of cores in cluster
if (dpmOptions$nCores == -1) {
nCores = max(1, detectCores() - 1)
} else if (dpmOptions$nCores == 0) {
nCores = detectCores()
} else {
nCores = max(dpmOptions, detectCores())
}
#make cluster
dpmOptions$cl = makeCluster(nCores)
#set random seed
clusterSetRNGStream(cl = dpmOptions$cl, iseed = dpmOptions$seed)
#export packages
tempResult = clusterEvalQ(cl = dpmOptions$cl, library(badpm))
} else {
set.seed(seed = dpmOptions$seed)
}
nUnits = nrow(dataMat)
nItems = ncol(dataMat)
nAttributes = ncol(qmatrix)
nClasses = 2^nAttributes
attributeNames = colnames(qmatrix)
if (is.null(attributeNames)) attributeNames = rep(paste0("att", 1:nAttributes))
attributeProfiles = matrix(data = 0, nrow = nClasses, ncol = nAttributes)
colnames(attributeProfiles) = attributeNames
for (att in 1:nClasses){
attributeProfiles[att, ] = dec2bin(decimal_number = (att-1), nattributes = nAttributes, basevector = rep(2,nAttributes))
}
classProbs = rep(NA, nClasses)
classProbsPrior = rep(1, nClasses)
classProbsChain = list()
for (chain in 1:dpmOptions$nChains){
classProbsChain[[chain]] = matrix(data = NA, nrow = dpmOptions$nSampled, ncol = nClasses)
}
masterX = attributeProfiles
masterX = cbind(matrix(data = 1, nrow = nClasses, ncol = 1), masterX)
colnames(masterX)[1] = "Intercept"
itemNames = colnames(dataMat)
if (is.null(itemNames)) itemNames = rep(paste0("item", 1:nItems))
items=list()
item = 1
for (item in 1:nitem){
items[[item]] = list(obsUnits = 1:nUnits, z = matrix(data = 0, nrow = nUnits, ncol = 1),
XBeta = matrix(data = 0, nrow = nUnits, ncol = 1), itemName = itemNames[item],
unitList = NULL, lowerBoundZ = matrix(data = NA, nrow = nUnits, ncol = 1),
upperBoundZ = matrix(data = NA, nrow = nUnits, ncol = 1), itemNumber = item,
dataVector = NULL)
#need to add: beta matrix, beta chain
#get number of parameters from Q-matrix
tempParam = determineItemParameters(item = item, qVector = qmatrix[item,], maxIxn = maxIxn)
items[[item]]$nParam = length(tempParam)
#get names associated with parameters
tempParamNames = convertItemParamList2Names(itemParamList = tempParam, attributeNames = attributeNames)
items[[item]]$paramNames = paste(itemNames[item], tempParamNames, sep=".")
items[[item]]$predNames = tempParamNames
#check that masterX has all columns; if not, add columns
masterX = checkMasterXCols(paramNames = tempParamNames, masterX = masterX)
#create beta vector
items[[item]]$beta = matrix(data = c(itemIntercept, itemMainEffect), nrow = items[[item]]$nParam, ncol = 1)
items[[item]]$betaMean = matrix(data = 0, nrow = items[[item]]$nParam, ncol = 1)
items[[item]]$betaCov = diag(items[[item]]$nParam)
rownames(items[[item]]$beta) = paste(itemNames[item], tempParamNames, sep=".")
#determine columns of masterX that correspond to parameters
items[[item]]$masterXcol = NULL
for (param in 1:length(tempParamNames)){
items[[item]]$masterXcol = c(items[[item]]$masterXcol, which(colnames(masterX) == tempParamNames[param]))
}
#create constraint matrix
items[[item]]$constraintMatrix = makeConstraintMatrix(paramNames = tempParamNames, masterX = masterX)
#create chain list matrices
items[[item]]$betaChain = list()
for (chain in 1:dpmOptions$nChains){
items[[item]]$betaChain[[chain]] = matrix(data = NA, nrow = dpmOptions$nSampled, ncol = items[[item]]$nParam)
colnames(items[[item]]$betaChain[[chain]]) = rownames(items[[item]]$beta)
}
# create constraint matrix
}
names(items) = itemNames
units = list()
unitClasses = rep(NA, nUnits)
unitClassChain = list()
for (chain in 1:dpmOptions$nChains){
unitClassChain[[chain]] = matrix(data = NA, nrow = dpmOptions$nSampled, ncol = nUnits)
}
unitNames = rownames(dataMat)
if (is.null(unitNames)) unitNames = rep(paste0("row", 1:nUnits))
for (unit in 1:nUnits){
units[[unit]] = list(unitClass = NA, unitName = unitNames[unit], dataList = NULL, dataVector = NULL,
unitNumber = unit)
for (item in 1:ncol(dataMat)){
if (!is.na(dataMat[unit,item])){
units[[unit]]$dataList = c(units[[unit]]$dataList, item)
units[[unit]]$dataVector = c(units[[unit]]$dataVector, dataMat[unit,item])
items[[item]]$unitList = c(items[[item]]$unitList, unit)
items[[item]]$dataVector = c(items[[item]]$dataVector, dataMat[unit,item])
if (dataMat[unit, item] == 0){
items[[item]]$lowerBoundZ[unit] = -Inf
items[[item]]$upperBoundZ[unit] = 0
} else {
items[[item]]$lowerBoundZ[unit] = 0
items[[item]]$upperBoundZ[unit] = Inf
}
}
}
}
names(units) = unitNames
cat("Entering Estimation Chains")
cat(" ")
totalIter = 0
chain = 1
classProbs = MCMCpack::rdirichlet(n = 1, alpha = classProbsPrior)
unitClasses = sample(x = 1:nClasses, size = nUnits, replace = TRUE, prob = classProbs)
classProbs
unitClasses = sample(x = 1:nClasses, size = nUnits, replace = TRUE, prob = classProbs)
unitClasses
if (dpmOptions$parallel){
clusterExport(cl = dpmOptions$cl, varlist = c("items", "masterX", "unitClasses"), envir = environment())
items = parLapply(cl=dpmOptions$cl, X = items, fun=drawItemParameters, masterX = masterX, unitClasses = unitClasses)
} else {
items = lapply(X = items, FUN = drawItemParameters, masterX = masterX, unitClasses = unitClasses)
}
lastIterNum = 0
iter = 1
units = units; items = items; nClasses = nClasses; classProbs = classProbs;
dpmOptions = dpmOptions; masterX = masterX
classVector = NULL
debug(fun = updateUnits)
estimatedNP = estimateDPM(dataMat = simulated$data, qmatrix = qmatrix, dpmOptions = dpmControl(seed=1, parallel=FALSE))
browser(updateUnit)
browser(updateUnit)
classVector = sapply(X = units, FUN = updateUnit, items = items, predictorMatrix = masterX,
nClasses = nClasses, classProbs = classProbs)
debug(fun = updateUnit)
estimatedNP = estimateDPM(dataMat = simulated$data, qmatrix = qmatrix, dpmOptions = dpmControl(seed=1, parallel=FALSE))
unitClassProb
unitClassProb
unitClassProb
unitClass
?poly
x = 1:10
poly(x,2)
poly
temp = poly(x,2)
cor(temp)
library(devtools)
ls
dir()
getwd()
setwd("/Users/jonathantemplin/Google Drive")
dir()
setwd("/Users/jonathantemplin/Google Drive/!01. Current Work")
dir()
setwd("/Users/jonathantemplin/Google Drive/!01. Current Work/02. Teaching/")
dir()
setwd("/Users/jonathantemplin/Google Drive/!01. Current Work/02. Teaching/EPSY 905 - Multivariate")
dir()
setwd("/Users/jonathantemplin/Google Drive/!01. Current Work/02. Teaching/EPSY 905 - Multivariate/R Packages")
dir()
setwd("/Users/jonathantemplin/Google Drive/!01. Current Work/02. Teaching/EPSY 905 - Multivariate/R Packages/HomeworkeR")
create(path = getwd())
create_package(path = getwd())
setwd("/Users/jonathantemplin/Google Drive/!01. Current Work/02. Teaching/EPSY 905 - Multivariate/R Packages/EPSY905R")
create_package(path = getwd())
